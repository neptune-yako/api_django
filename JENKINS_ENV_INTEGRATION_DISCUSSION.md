# Jenkins 环境集成与鉴权方案讨论
> 创建日期: 2025-12-18
> 状态: 讨论中 / 待确认

## 0. 方案摘要 (Executive Summary)

**🧐 为什么我们要讨论这个问题？**
随着我们开始将 Jenkins 集成到定时任务中，面临一个架构抉择：**测试环境（Environment）是否应该存储 Jenkins 的 URL 和 Token？**
如果不存，系统怎么去调用 Jenkins？如果存，是否存在安全和维护隐患？同时，我们的系统需要如何智能地判断当前是去跑 Jenkins 还是跑本地用例？

**💡 核心建议方案：**
我们推荐 **不修改数据库结构**，而是采用 **“配置分离 + 运行时注入”** 的策略。

1.  **拒绝硬编码**：不要把 Jenkins Token 写死在“测试环境”表里。这会导致维护噩梦（改一个密码要更几十个环境）。
2.  **单一数据源**：Jenkins 配置只存一份（在 `JenkinsServer` 表）。
3.  **自动分流**：任务执行时，后台自动判断：关联了 Jenkins Job 就跑 Jenkins，关联了本地套件就跑本地。
4.  **能力注入**：系统会在后台自动把 Jenkins 权限“注入”给所有任务。本地脚本如果想调 Jenkins，直接用变量就能调，无需关心 Token 在哪。

---

## 1. 问题背景

随着 **1.4 定时构建任务管理** 需求的推进，我们需要解决以下核心问题：

1.  **鉴权依赖**：在执行自动化测试或定时任务时，需要调用 Jenkins API，这依赖于 `URL`、`Username` 和 `Token`。
2.  **系统区分**：系统如何知道当前任务应该调用 Jenkins 还是执行本地测试用例？
3.  **环境穿透**：如何在不强制绑定的情况下，让本地测试脚本也能具备调用 Jenkins 的能力（软依赖）？

---

## 2. 方案分析

### 🔴 方案 A：在“测试环境”中硬编码 (不推荐)
直接修改 `Environment` 表增加 Jenkins 字段。已在上一轮讨论中否决，因其存在安全隐患和维护成本高的问题。

### 🟢 方案 B：引用与运行时注入 (推荐方案)

采用 **“配置与环境分离，引用而非硬编码”** 的架构。利用已有的 `JenkinsServer` 模型作为唯一的数据源。

---

## 3. 核心机制设计 (New!)

基于开发团队的深入讨论，我们明确了以下两个核心机制来解决“区分”和“依赖”的问题。

### 3.1 机制一：数据驱动的执行分流 (Distinction)

系统不需要预先定义任务类型，而是根据 **Plan (测试计划) 的关联数据** 自动决定执行流程。支持“双重执行”。

**在 `run_task` 执行时的逻辑流：**

1.  **检查 Jenkins 关联**：
    *   查询 `plan.jenkins_jobs.all()`。
    *   **如果有** 👉 自动触发 Jenkins 构建 (API 调用)。
    *   *场景：定时触发 CI/CD 流水线。*

2.  **检查本地套件关联**：
    *   查询 `plan.scene.all()`。
    *   **如果有** 👉 启动本地测试引擎 (`ApiEngine`)。
    *   *场景：执行接口自动化测试用例。*

3.  **混合模式 (Hybrid)**：
    *   如果两者都有，则依次执行（如：先触发 Jenkins 部署环境，部署成功后自动开始跑本地测试）。

### 3.2 机制二：全局环境软注入 (Soft Dependency)

我们不强迫任务显式依赖 Jenkins，而是采用 **“默认注入，按需使用”** 的策略。

**实现逻辑：**
在任何任务（无论是本地还是 Jenkins）启动前，后端自动执行“环境注入”：

1.  **静默读取**：自动查询 `JenkinsServer` 表中启用的服务器配置。
2.  **动态注入**：将 `JENKINS_URL` 和 `JENKINS_TOKEN` 注入到测试引擎的全局变量 (`global_variable`) 中。
3.  **效果**：
    *   **普通用例**：无感知，完全不受影响。
    *   **高级用例**：如果测试脚本（Python/YAML）中需要调用 Jenkins（例如：查询构建状态、触发下游Job），可以直接使用全局变量 `${_JENKINS_URL}` 进行操作。

---

## 4. 常见问题解答 (Q&A)

**Q1: 这个方案只解决定时任务的问题吗？其他调用（如网页手动触发）怎么办？**
**A**: 不是。这套机制是**全平台通用**的。因为我们建立了统一的 `JenkinsServer` 配置源，未来无论是网页上手动点击执行、还是用例中 API 触发，所有功能都会去同一个地方（JenkinsServer 表）拿 Token。**这解决的是全平台的鉴权问题**，一劳永逸。

**Q2: 既然不把配置写在环境里，前端是不是需要多做一个页面来管理？**
**A**: **是的，必须要有。** 我们需要开发一个【Jenkins 服务器管理】的页面（CRUD）。但这属于即使投入，因为：
*   这个页面只需开发一次。
*   相比于在几十个【测试环境】页面里重复填写 token，维护一个集中管理页面的成本要低得多。

**Q3: 只配置一个 Jenkins Server，将来多 Node 节点会有影响吗？**
**A**: **完全没有影响。**
*   我们对接的是 Jenkins **Master** 节点。
*   具体的 Job 在哪个 Node 上跑（Slave/Agent），是由 Jenkins Master 自己调度的（基于 Label）。
*   我们的系统只需要告诉 Master“帮我把这个 Job 跑起来”，至于它在哪个 Node 上跑，对我们是透明的。这也是标准且安全的做法。

**Q4: 我没有配置 JenkinsJob 的页面，是不是得在前端写一个页面进行 Job 的 CRUD？前端调用测试计划时能正常执行吗？**
**A**:
1.  **关于页面**：是的，必须要有。你需要一个页面（或者在测试计划详情页）来关联 Job。我们之前的“同步功能”解决了 Create，现在需要解决 Link（关联）。
2.  **关于执行**：前端**完全不需要改动**，也不需要感知变化。用户点击“运行计划”时，后端接管一切。后端会检查有没有关联 Job，有就跑 Jenkins，没有就跑本地。用户看到的体验是一致的。

**Q5: 系统会怎么样知道这个需要 Jenkins？哪个不需要？还是相当于给全部测试方法加上一些Jenkins数据？**
**A**:
系统采用 **“显式触发 + 隐式注入”** 的双重逻辑：
1.  **怎么知道要跑 Jenkins (Trigger)**：靠**显式的数据库关联**。代码检查 `plan.jenkins_jobs.all()` 是否为空。不为空才触发构建。
2.  **怎么给数据 (Injection)**：靠**隐式的全局注入**。不管你需不需要，系统都会在启动时把 `_JENKINS_URL` 和 `TOKEN` 注入到全局变量。需要的用例自己取用，不需要的用例不受影响。这样既灵活又没有侵入性。

---

## 5. 推荐实施路径

### 步骤 1：数据准备 (保持现状)
*   **JenkinsServer**：作为唯一的配置源 (SSOT)。
*   **JenkinsJob**：作为 Plan 和 Jenkins 之间的桥梁。

### 步骤 2：核心代码改造 (Backend)
修改 `backend/plan/tasks.py` 中的 `run_task` 函数：

```python
def run_task(env_id, task_id, tester):
    plan = Plan.objects.get(id=task_id)
    
    # 1. 环境注入 (Soft Dependency)
    # 无论跑什么，先把 Jenkins 配置注入到全局变量，供脚本按需自取
    jenkins_server = JenkinsServer.objects.filter(is_active=True).first()
    if jenkins_server:
        # 注入逻辑...
        pass

    # 2. 执行 Jenkins 任务 (如果有)
    jenkins_jobs = plan.jenkins_jobs.all()
    if jenkins_jobs:
        # 循环触发构建...
        pass

    # 3. 执行本地测试套件 (如果有)
    scenes = plan.scene.all()
    if scenes:
        # 原有 run_test 逻辑...
        pass
```

---

## 6. 结论

**此方案的优势：**
1.  **零侵入**：不需要修改 `Environment` 表结构。
2.  **灵活性**：同一个 Plan 可以是纯 Jenkins 任务，纯本地任务，或者两者的混合编排。
3.  **可扩展**：本地测试用例默认获得了操作 Jenkins 的能力，为编写复杂的集成测试场景（如 CI 状态巡检）提供了基础。
